```@setup liga
using Liga
layout(3)
```
# Types

For each space we have three *types*. In all spaces, *geometric algebra*  elements can be represented divided in *basis*, *multivectors* and *blades*. All operations and how each *type* works will be explained later in this guide.

### Basis types

####  k-basis (```kbasis```)

The ```kbasis``` *type* is the first of all *types*. All of the other *types* depend on this in some level.

This *type* represents the basis elements of the *geometric algebra* of \$\mathbb{R}^k\$, it depends of a k-dimensional logical array and a scalar, generally

    kbasis(x::Vector{Bool}, a::Number)

will create a basis element from ```x``` and ```a```. For example,

```
kbasis([false, true, false], 3.5)
```
return the element ```3.5e2``` wich is in \$\mathbb{G}_3\$ space.

As commented in [Layout Section](gettingstarted.md) it's possible to create a ```kbasis``` using the base operator ```*``` between a ```Number``` and a ```Vector{Bool}```, as follows

    2.0*[false, true, true]

will return

    2.0e23

and, using the *layout* elements, it can be used

```@repl liga
2.0*e23
```
to create the same element above.

####  p-basis (```pbasis```)

To create an element of this *type* is required, in addition to the logical array and scalar, one more logical element, that is,

```
pbasis(x::Vector{Bool}, y::Bool, a::Number)
```
where the second parameter represents the basis element that squares to ```-1```. For example,

```
pbasis([true, false, true, true], true, 1.0)
```
returns the element of \$ \mathbb{G}_{4,1} \$

    1.0e13+-

where the basis element ```e3``` is replaced by ```e+``` with the same properties and is added the basis element ```e-``` that squares to ```-1```.


#### c-basis (```cbasis```)

This _type_ instead of use ```e-``` as addition basis element, the elements ```e∞``` and ```e∘``` are used. To call an element of this *type* it is necessary, besides the logical array and scale, two logical elements, as follows

    cbasis(x::Vector{Bool}, y::Bool, z::Bool, a::Number)

the second parameter represents the basis element ``e∞`` and the third represents `e∘`. As in the previous cases, instead of use the `Vector{Bool}` can be used the elements generated by the layout function, that is, if was called the layout(3) before, then

    cbasis(e12, true, false, 2.0)

will return

    2.0e12∞

Shortly `e∞ = e- + e+` and `e∘ = 0.5(e- - e+)` hence `e∞² = e∘² = 0` and `e∞e∘ = -1`.

### Multivector types

The *multivectors types* are composed of a vector of basis elements, each coordinate of the vector represents a portion of the sum that will generate the multivector itself.

#### k-multivector (```kmultvec```)

This *type* is composed of a `kbasis` vector and represents an arbitrary element of the *geometric algebra* \$\mathbb{G}_k\$.

    kmultvec(X::Vector{kbasis})

once created the `kmultvec` its coordinates elements will be arranged as a sum,

    kmultvec([kbasis(e1, 1.0), kbasis(id, 2.4), kbasis(e123, -1.0)])

will create the elmemnt

    1.0e1 + 2.4 + -1.0

it can be created by using the sum directly as follows

    kbasis(e1, 1.0) + kbasis(id, 2.4) + kbasis(e123, -1.0)

since the sum of `kbasis`, as will be explained later, generates an element of *type* `kmultvec` in most cases.

#### p-multivector (```pmultvec```)

The only difference here is that instead of being composed of a `kbasis` vector the `pmultvec` is composed of a vector `pbasis`,

    pmultvec(X::Vector{pbasis})

but, in the same way as the previous one, its coordinates elements  will be arranged as a sum.

#### c-multivector (```cmultvec```)

Again, the difference remains in the vector *type*, which in this case will be a vector composed of `cbasis` elements,

    cmultvec(X::Vector{cbasis})

Other than that, everything follows in the same way.

### Blade *types*

These *types* represent elements of the *geometric algebra* called blades, for this we need a set 1.i. of 1-vectors.

#### k-Blades (```kblade```)

The `kblade` *type* represents a *blade* in \$\mathbb{G}_k\$ space and is composed of a `kmultvec` vector

    kblade(A::Vector{kmultvec})

and, if the introduced vector is composed of l.i 1-vectors, this will generate a *blade* formed by the *outer product* of the coordinates of this vector. For example,

    kblade([kmultvec(kbasis(e1)), kmultvec(kbasis(e2)), kmultvec(kbasis(e3))])

generates the `kblade`

    (e1)∧(e2)∧(e3)


#### p-Blades (```pblade```)

This *type* represents a *blade* in (k,1) *geometric algebra* space the only difference between this *type* and the previous one is that it is composed of a `pmultvec` vector.

    pblade(A::Vector{pmultvec})

however, as in the previous case, this will generate a *blade* formed by the *outer product* of the coordinates of the vector.

#### c-Blades (```cblade```)

As for `kblade` and `pblade` this *type* represents a *blade* in (k+1,1) *geometric algebra* space and the difference is in the *type* that composes it, in this case `cmultvec`.

    cblade(A::Vector{cmultvec})

and as in previous cases, this will generate the *blade* composed by the *outer product* of its coordinates.

**All basis types can be called using the functions `kb` for `kbasis`, `pb` to `pbasis` and `cb` for `cbasis`**
